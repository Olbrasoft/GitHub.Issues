using Microsoft.Extensions.Logging;

namespace Olbrasoft.GitHub.Issues.Text.Transformation.Abstractions;

/// <summary>
/// Composite embedding service that tries multiple providers in sequence until one succeeds.
/// Implements fallback pattern to ensure embeddings are always generated.
/// </summary>
public class FallbackEmbeddingService : IEmbeddingService
{
    private readonly IReadOnlyList<IEmbeddingService> _providers;
    private readonly ILogger<FallbackEmbeddingService> _logger;

    public FallbackEmbeddingService(
        IEnumerable<IEmbeddingService> providers,
        ILogger<FallbackEmbeddingService> logger)
    {
        _providers = providers.ToList();
        _logger = logger;

        _logger.LogInformation("FallbackEmbeddingService initialized with {Count} providers", _providers.Count);
    }

    public bool IsConfigured => _providers.Any(p => p.IsConfigured);

    public async Task<bool> IsAvailableAsync(CancellationToken cancellationToken = default)
    {
        foreach (var provider in _providers)
        {
            if (provider.IsConfigured && await provider.IsAvailableAsync(cancellationToken))
            {
                return true;
            }
        }
        return false;
    }

    public async Task<float[]?> GenerateEmbeddingAsync(
        string text,
        EmbeddingInputType inputType = EmbeddingInputType.Document,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return null;
        }

        var providerIndex = 0;
        foreach (var provider in _providers)
        {
            providerIndex++;
            var providerName = provider.GetType().Name.Replace("EmbeddingService", "");

            if (!provider.IsConfigured)
            {
                _logger.LogDebug("Provider {Index}/{Total} ({Name}) is not configured, skipping",
                    providerIndex, _providers.Count, providerName);
                continue;
            }

            try
            {
                var embedding = await provider.GenerateEmbeddingAsync(text, inputType, cancellationToken);
                if (embedding != null)
                {
                    _logger.LogInformation("Embedding generated by provider {Index}/{Total} ({Name}), dimensions: {Dimensions}",
                        providerIndex, _providers.Count, providerName, embedding.Length);
                    return embedding;
                }

                _logger.LogWarning("Provider {Index}/{Total} ({Name}) returned null embedding, trying next",
                    providerIndex, _providers.Count, providerName);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Provider {Index}/{Total} ({Name}) failed with error, trying next",
                    providerIndex, _providers.Count, providerName);
            }
        }

        _logger.LogError("All {Count} embedding providers failed to generate embedding for text: {TextPreview}...",
            _providers.Count, text.Length > 50 ? text[..50] : text);

        return null;
    }
}
